/*
  Copyright (C) 2014-2017 Carlos Montiers Aguilera

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Carlos Montiers Aguilera
  cmontiers@gmail.com
 */

/*
 * Sprite v2.3.1
 * For compilation with tdm-gcc :
 * gcc -Wl,-e,__start -nostartfiles -m32 -O3 -s sprite.c assoc-array.c -o SPRITE.EXE -fno-omit-frame-pointer -Wall
 */

#define UNICODE
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>
#include <ctype.h>
#include <locale.h>
#include "assoc-array.h"

#define ERROR_READING_THE_SCREEN  1
#define ERROR_RECTANGLE_TOO_BIG  2

#define MIN_SPRITE_FILE_SIZE (0x8)

void exit_error(int);
void display_author(void);

typedef struct {
    int newmode;
} _startupinfo;

int __wgetmainargs(int *_Argc, wchar_t *** _Argv, wchar_t *** _Env,
        int _DoWildCard, _startupinfo * _StartInfo);

void *read_spr_file(WCHAR * fileName) {

    void *buffer;
    HANDLE hFile;
    LARGE_INTEGER li; //li.LowPart have the normal size
    DWORD sprite_filesize;
    DWORD bytes_read;
    COORD spriteBufferSize;

    hFile = CreateFileW(fileName,
            GENERIC_READ,
            FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
        return NULL;
    }

    if (!GetFileSizeEx(hFile, &li)) {
        CloseHandle(hFile);
        return NULL;
    }
    // Minimal sprite file size
    sprite_filesize = li.LowPart;
    if (sprite_filesize < MIN_SPRITE_FILE_SIZE) {
        CloseHandle(hFile);
        return NULL;
    }

    buffer = (void *) malloc(sprite_filesize);
    if (!buffer) {
        CloseHandle(hFile);
        return NULL;
    }

    if (!ReadFile(hFile, buffer, sprite_filesize, &bytes_read, NULL)
            || (bytes_read != sprite_filesize)) {
        free(buffer);
        CloseHandle(hFile);
        return NULL;
    }
    // Prevent malformed binary file
    spriteBufferSize = *(COORD *) buffer;
    if ((spriteBufferSize.Y < 0) || (spriteBufferSize.X < 0)
            || ((4 + ((spriteBufferSize.Y * spriteBufferSize.X) << 2)) !=
            sprite_filesize)
            ) {
        free(buffer);
        CloseHandle(hFile);
        return NULL;
    }

    CloseHandle(hFile);
    return buffer;
}

void _start(void) {
    _startupinfo start_info = {0};
    INT argc;
    WCHAR **argv;
    WCHAR **env;

    CHAR_INFO spBuffer[0xFE01]; //4 * (0xFF * 0xFF) = 254 KB

    void *spritefile;
    struct AssocArray assocarray;
    struct AssocArrayElement *current;
    struct AssocArrayElement *next;
    HANDLE Hout;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD ScreenMaxIndex;
    COORD SpBufferCoord;
    COORD ScreenCoord;
    WCHAR *SpriteFileName;
    int arg_index;
    int limit;

    UINT spIncrement;
    CHAR_INFO *spBufferIT;
    COORD spBufferSize;

    UINT dsIncrement;
    CHAR_INFO *dsBuffer;
    CHAR_INFO *dsBufferIT;
    COORD dsBufferSize;

    SMALL_RECT screen_zone;
    SMALL_RECT rectangle;
    INT rowDS_begin;
    INT rowDS_limit;
    INT columnDS_begin;
    INT columnDS_limit;
    INT DS_width;
    INT DS_eight;
    INT i, j;

    if (__wgetmainargs(&argc, &argv, &env, 0, &start_info) < 0) {
        ExitProcess(-1);
    }

    if (1 == argc) {
        display_author();
    } else if (argc >= 4) {

        assocarray_init(&assocarray);

        Hout = CreateFileW(L"CONOUT$",
                (GENERIC_READ | GENERIC_WRITE),
                (FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL, OPEN_EXISTING, 0, NULL);

        GetConsoleScreenBufferInfo(Hout, &csbi);

        // Read only visible screen buffer rectangle
        // instead all screen buffer (csbi.dwSize)
        // For example:
        // From a screen buffer of 80x300 we read only the window rectangle than can be 80x39

        spBufferSize.X = (ScreenMaxIndex.X =
                (csbi.srWindow.Right - csbi.srWindow.Left)) + 1;
        spBufferSize.Y = (ScreenMaxIndex.Y =
                (csbi.srWindow.Bottom - csbi.srWindow.Top)) + 1;

        if ((spBufferSize.X > 0xFF) || (spBufferSize.Y > 0xFF)) {
            exit_error(ERROR_RECTANGLE_TOO_BIG);
        }

        SpBufferCoord.X = 0;
        SpBufferCoord.Y = 0;
        screen_zone = csbi.srWindow;

        if (!ReadConsoleOutputW(Hout,
                spBuffer,
                spBufferSize, SpBufferCoord, &screen_zone)) {
            exit_error(ERROR_READING_THE_SCREEN);
        }

        arg_index = 1; // Begin in argv[1]
        limit = argc - 1;

        while (arg_index < limit) {

            ScreenCoord.Y = (SHORT) _wtol(argv[arg_index++]); //row
            ScreenCoord.X = (SHORT) _wtol(argv[arg_index++]); //column
            SpriteFileName = (argv[arg_index++]);

            if ((ScreenCoord.X > ScreenMaxIndex.X)
                    || (ScreenCoord.Y > ScreenMaxIndex.Y)) {
                continue;
            }

            if (!
                    (spritefile =
                    assocarray_get(&assocarray, SpriteFileName))) {

                spritefile = read_spr_file(SpriteFileName);
                if (!spritefile) {
                    fwprintf(stderr, L"Cannot use the file: %ls\n",
                            SpriteFileName);
                    continue;
                }

                assocarray_add(&assocarray, SpriteFileName, spritefile);
            }

            dsBufferSize = *(COORD *) spritefile;
            dsBuffer = (CHAR_INFO *) (sizeof (COORD) + (BYTE *) spritefile);

            columnDS_limit = dsBufferSize.X - 1;
            rowDS_limit = dsBufferSize.Y - 1;
            columnDS_begin = 0;
            rowDS_begin = 0;

            rectangle.Right = (rectangle.Left =
                    ScreenCoord.X) + columnDS_limit;
            rectangle.Bottom = (rectangle.Top =
                    ScreenCoord.Y) + rowDS_limit;

            if (rectangle.Left < 0) {
                columnDS_begin -= (rectangle.Left);
            }

            if (rectangle.Top < 0) {
                rowDS_begin -= (rectangle.Top);
            }

            if (rectangle.Right > ScreenMaxIndex.X) {
                columnDS_limit -= (rectangle.Right - ScreenMaxIndex.X);
            }

            if (rectangle.Bottom > ScreenMaxIndex.Y) {
                rowDS_limit -= (rectangle.Bottom - ScreenMaxIndex.Y);
            }

            DS_width = columnDS_limit - columnDS_begin + 1;
            DS_eight = rowDS_limit - rowDS_begin + 1;

            if ((DS_width < 1) || (DS_eight < 1)) {
                continue;
            }

            dsBufferIT =
                    dsBuffer + (rowDS_begin * dsBufferSize.X) + columnDS_begin;

            dsIncrement = dsBufferSize.X - DS_width;

            if (ScreenCoord.Y < 0) {
                ScreenCoord.Y = 0;
            }

            if (ScreenCoord.X < 0) {
                ScreenCoord.X = 0;
            }

            spBufferIT =
                    spBuffer + (ScreenCoord.Y * spBufferSize.X +
                    ScreenCoord.X);

            spIncrement = spBufferSize.X - DS_width;

            for (i = rowDS_begin; i <= rowDS_limit; ++i) {
                for (j = columnDS_begin; j <= columnDS_limit; ++j) {
                    if (dsBufferIT->Char.UnicodeChar) {
                        spBufferIT->Char.UnicodeChar =
                                dsBufferIT->Char.UnicodeChar;
                        spBufferIT->Attributes = dsBufferIT->Attributes;
                    }

                    ++spBufferIT;
                    ++dsBufferIT;
                }
                dsBufferIT += dsIncrement;
                spBufferIT += spIncrement;
            }

        }

        WriteConsoleOutputW(Hout,
                spBuffer,
                spBufferSize, SpBufferCoord, &screen_zone);

    }

    current = assocarray.head;
    while (current) {
        //printf("assocarray[%ls]\n", current->key);
        next = current->next;
        free(current->obj);
        free(current);
        current = next;
    }

    ExitProcess(0);

}

void exit_error(int code) {
    switch (code) {
        case ERROR_READING_THE_SCREEN:
            fwprintf(stderr, L"Error reading the screen.\n");
            break;
        case ERROR_RECTANGLE_TOO_BIG:
            fwprintf(stderr, L"Rectangle too big.\n");
            break;
    }

    ExitProcess(code);
}

void display_author() {
    BYTE carlos[0x640] = {
        0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB,
        0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB,
        0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB,
        0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB,
        0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x00, 0x00, 0x92, 0x25, 0xEC,
        0x00, 0x92, 0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x92,
        0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x83,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x00, 0x00, 0x92, 0x25, 0xEC,
        0x00, 0x92, 0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x92,
        0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x83, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x83,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0xCC, 0x00, 0x88, 0x25, 0xCC, 0x00, 0x88,
        0x25, 0x99, 0x00, 0x88, 0x25, 0x99, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x92, 0x25, 0xEC, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x83, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x83,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0xCC, 0x00, 0x88, 0x25, 0xCC, 0x00, 0x88,
        0x25, 0x99, 0x00, 0x88, 0x25, 0x99, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x92, 0x25, 0xEC, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x83, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x92, 0x25, 0xEC,
        0x00, 0x92, 0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x92,
        0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x83, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x92, 0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x92,
        0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x83, 0x00, 0x88, 0x25, 0x83, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0xAA, 0x00, 0x88, 0x25, 0x0A,
        0x00, 0x88, 0x25, 0xAA, 0x00, 0x88, 0x25, 0xAA, 0x00, 0x88,
        0x25, 0xAA, 0x00, 0x88, 0x25, 0xAA, 0x00, 0x88, 0x25, 0x0A,
        0x00, 0x88, 0x25, 0xAA, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88,
        0x25, 0x0A, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88,
        0x25, 0x0A, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x92,
        0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88,
        0x25, 0x0A, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x92, 0x25, 0xEC, 0x00, 0x92, 0x25, 0xEC, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88,
        0x25, 0x0A, 0x00, 0x88, 0x25, 0x0A, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0x8B, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88,
        0x25, 0x00, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xFF,
        0x00, 0x88, 0x25, 0xFF, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x00,
        0x00, 0x88, 0x25, 0x00, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88,
        0x25, 0x33, 0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0x33,
        0x00, 0x88, 0x25, 0x33, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB,
        0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB,
        0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB,
        0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88,
        0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB,
        0x00, 0x88, 0x25, 0xBB, 0x00, 0x88, 0x25, 0xBB, 0x00
    };
    COORD dwBufferSize = {20, 20};
    COORD coord = {0, 0};
    COORD txt_coord = {0, 20};
    SMALL_RECT rectangle = {0, 0, 19, 19};
    HANDLE hOut;
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    DWORD nLength;
    DWORD numberOfCharsWritten;

    hOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (GetConsoleScreenBufferInfo(hOut, &csbi)) {

        nLength = csbi.dwSize.X * csbi.dwSize.Y;

        if (FillConsoleOutputAttribute(hOut,
                0x00, nLength, coord,
                &numberOfCharsWritten)) {

            if (FillConsoleOutputCharacterW(hOut,
                    0x20, nLength, coord,
                    &numberOfCharsWritten)) {

                if (WriteConsoleOutputW(hOut,
                        (const CHAR_INFO *) carlos,
                        dwBufferSize, coord, &rectangle)) {
                    SetConsoleCursorPosition(hOut, coord);
                    SetConsoleCursorPosition(hOut, txt_coord);
                }
            }

        }

    }

    fwprintf(stdout,
            L"\r\nSPRITE.EXE was programmed by Carlos Montiers Aguilera\r\n");

}
